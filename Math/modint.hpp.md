---
data:
  _extendedDependsOn: []
  _extendedRequiredBy:
  - icon: ':x:'
    path: Convolution/arbitrary.hpp
    title: Arbitrary Mod Convolution
  - icon: ':warning:'
    path: Math/bigint.hpp
    title: Big Integer(Float)
  _extendedVerifiedWith:
  - icon: ':x:'
    path: Verify/LC_bernoulli_number.test.cpp
    title: Verify/LC_bernoulli_number.test.cpp
  - icon: ':x:'
    path: Verify/LC_bitwise_and_convolution.test.cpp
    title: Verify/LC_bitwise_and_convolution.test.cpp
  - icon: ':x:'
    path: Verify/LC_bitwise_xor_convolution.test.cpp
    title: Verify/LC_bitwise_xor_convolution.test.cpp
  - icon: ':x:'
    path: Verify/LC_convolution_mod.test.cpp
    title: Verify/LC_convolution_mod.test.cpp
  - icon: ':x:'
    path: Verify/LC_convolution_mod_1000000007.test.cpp
    title: Verify/LC_convolution_mod_1000000007.test.cpp
  - icon: ':x:'
    path: Verify/LC_convolution_mod_2.test.cpp
    title: Verify/LC_convolution_mod_2.test.cpp
  - icon: ':x:'
    path: Verify/LC_deque_operate_all_composite.test.cpp
    title: Verify/LC_deque_operate_all_composite.test.cpp
  - icon: ':x:'
    path: Verify/LC_dynamic_tree_vertex_set_path_composite.test.cpp
    title: Verify/LC_dynamic_tree_vertex_set_path_composite.test.cpp
  - icon: ':x:'
    path: Verify/LC_enumerate_cliques.test.cpp
    title: Verify/LC_enumerate_cliques.test.cpp
  - icon: ':x:'
    path: Verify/LC_exp_of_formal_power_series.test.cpp
    title: Verify/LC_exp_of_formal_power_series.test.cpp
  - icon: ':x:'
    path: Verify/LC_find_linear_recurrence.test.cpp
    title: Verify/LC_find_linear_recurrence.test.cpp
  - icon: ':x:'
    path: Verify/LC_gcd_convolution.test.cpp
    title: Verify/LC_gcd_convolution.test.cpp
  - icon: ':x:'
    path: Verify/LC_hafnian_of_matrix.test.cpp
    title: Verify/LC_hafnian_of_matrix.test.cpp
  - icon: ':x:'
    path: Verify/LC_inv_of_formal_power_series.test.cpp
    title: Verify/LC_inv_of_formal_power_series.test.cpp
  - icon: ':x:'
    path: Verify/LC_kth_term_of_linearly_recurrent_sequence.test.cpp
    title: Verify/LC_kth_term_of_linearly_recurrent_sequence.test.cpp
  - icon: ':x:'
    path: Verify/LC_lcm_convolution.test.cpp
    title: Verify/LC_lcm_convolution.test.cpp
  - icon: ':x:'
    path: Verify/LC_log_of_formal_power_series.test.cpp
    title: Verify/LC_log_of_formal_power_series.test.cpp
  - icon: ':x:'
    path: Verify/LC_many_factorials.test.cpp
    title: Verify/LC_many_factorials.test.cpp
  - icon: ':x:'
    path: Verify/LC_matrix_det.test.cpp
    title: Verify/LC_matrix_det.test.cpp
  - icon: ':x:'
    path: Verify/LC_matrix_product.test.cpp
    title: Verify/LC_matrix_product.test.cpp
  - icon: ':x:'
    path: Verify/LC_multipoint_evaluation.test.cpp
    title: Verify/LC_multipoint_evaluation.test.cpp
  - icon: ':x:'
    path: Verify/LC_multivariate_convolution.test.cpp
    title: Verify/LC_multivariate_convolution.test.cpp
  - icon: ':x:'
    path: Verify/LC_multivariate_convolution_cyclic.test.cpp
    title: Verify/LC_multivariate_convolution_cyclic.test.cpp
  - icon: ':x:'
    path: Verify/LC_partition_function.test.cpp
    title: Verify/LC_partition_function.test.cpp
  - icon: ':x:'
    path: Verify/LC_point_set_range_composite.test.cpp
    title: Verify/LC_point_set_range_composite.test.cpp
  - icon: ':x:'
    path: Verify/LC_point_set_range_sort_range_composite.test.cpp
    title: Verify/LC_point_set_range_sort_range_composite.test.cpp
  - icon: ':x:'
    path: Verify/LC_polynomial_interpolation.test.cpp
    title: Verify/LC_polynomial_interpolation.test.cpp
  - icon: ':x:'
    path: Verify/LC_polynomial_taylor_shift.test.cpp
    title: Verify/LC_polynomial_taylor_shift.test.cpp
  - icon: ':x:'
    path: Verify/LC_pow_of_formal_power_series.test.cpp
    title: Verify/LC_pow_of_formal_power_series.test.cpp
  - icon: ':x:'
    path: Verify/LC_product_of_polynomial_sequence.test.cpp
    title: Verify/LC_product_of_polynomial_sequence.test.cpp
  - icon: ':x:'
    path: Verify/LC_queue_operate_all_composite.test.cpp
    title: Verify/LC_queue_operate_all_composite.test.cpp
  - icon: ':x:'
    path: Verify/LC_range_affine_range_sum.test.cpp
    title: Verify/LC_range_affine_range_sum.test.cpp
  - icon: ':x:'
    path: Verify/LC_shift_of_sampling_points_of_polynomial.test.cpp
    title: Verify/LC_shift_of_sampling_points_of_polynomial.test.cpp
  - icon: ':x:'
    path: Verify/LC_sparse_matrix_det.test.cpp
    title: Verify/LC_sparse_matrix_det.test.cpp
  - icon: ':x:'
    path: Verify/LC_static_rectangle_add_rectangle_sum.test.cpp
    title: Verify/LC_static_rectangle_add_rectangle_sum.test.cpp
  - icon: ':x:'
    path: Verify/LC_stirling_number_of_the_first_kind.test.cpp
    title: Verify/LC_stirling_number_of_the_first_kind.test.cpp
  - icon: ':x:'
    path: Verify/LC_stirling_number_of_the_second_kind.test.cpp
    title: Verify/LC_stirling_number_of_the_second_kind.test.cpp
  - icon: ':x:'
    path: Verify/LC_subset_convolution.test.cpp
    title: Verify/LC_subset_convolution.test.cpp
  - icon: ':x:'
    path: Verify/LC_sum_of_exponential_times_polynomial.test.cpp
    title: Verify/LC_sum_of_exponential_times_polynomial.test.cpp
  - icon: ':x:'
    path: Verify/LC_sum_of_exponential_times_polynomial_limit.test.cpp
    title: Verify/LC_sum_of_exponential_times_polynomial_limit.test.cpp
  - icon: ':x:'
    path: Verify/LC_sum_of_totient_function.test.cpp
    title: Verify/LC_sum_of_totient_function.test.cpp
  - icon: ':x:'
    path: Verify/LC_system_of_linear_equations.test.cpp
    title: Verify/LC_system_of_linear_equations.test.cpp
  - icon: ':x:'
    path: Verify/LC_vertex_set_path_composite.test.cpp
    title: Verify/LC_vertex_set_path_composite.test.cpp
  - icon: ':x:'
    path: Verify/YUKI_1080.test.cpp
    title: Verify/YUKI_1080.test.cpp
  - icon: ':x:'
    path: Verify/YUKI_1112.test.cpp
    title: Verify/YUKI_1112.test.cpp
  - icon: ':x:'
    path: Verify/YUKI_1781.test.cpp
    title: Verify/YUKI_1781.test.cpp
  - icon: ':x:'
    path: Verify/YUKI_2097.test.cpp
    title: Verify/YUKI_2097.test.cpp
  - icon: ':x:'
    path: Verify/YUKI_310.test.cpp
    title: Verify/YUKI_310.test.cpp
  _isVerificationFailed: true
  _pathExtension: hpp
  _verificationStatusIcon: ':x:'
  attributes:
    document_title: Modint
    links: []
  bundledCode: "#line 2 \"Math/modint.hpp\"\n\r\ntemplate <unsigned mod = 1000000007>\
    \ struct fp {\r\n    unsigned v;\r\n    static constexpr int get_mod() {\r\n \
    \       return mod;\r\n    }\r\n    constexpr unsigned inv() const {\r\n     \
    \   assert(v != 0);\r\n        int x = v, y = mod, p = 1, q = 0, t = 0, tmp =\
    \ 0;\r\n        while (y > 0) {\r\n            t = x / y;\r\n            x -=\
    \ t * y, p -= t * q;\r\n            tmp = x, x = y, y = tmp;\r\n            tmp\
    \ = p, p = q, q = tmp;\r\n        }\r\n        if (p < 0)\r\n            p +=\
    \ mod;\r\n        return p;\r\n    }\r\n    constexpr fp(ll x = 0) : v(x >= 0\
    \ ? x % mod : (mod - (-x) % mod) % mod) {}\r\n    fp operator-() const {\r\n \
    \       return fp() - *this;\r\n    }\r\n    fp pow(ull t) {\r\n        fp res\
    \ = 1, b = *this;\r\n        while (t) {\r\n            if (t & 1)\r\n       \
    \         res *= b;\r\n            b *= b;\r\n            t >>= 1;\r\n       \
    \ }\r\n        return res;\r\n    }\r\n    fp &operator+=(const fp &x) {\r\n \
    \       if ((v += x.v) >= mod)\r\n            v -= mod;\r\n        return *this;\r\
    \n    }\r\n    fp &operator-=(const fp &x) {\r\n        if ((v += mod - x.v) >=\
    \ mod)\r\n            v -= mod;\r\n        return *this;\r\n    }\r\n    fp &operator*=(const\
    \ fp &x) {\r\n        v = ull(v) * x.v % mod;\r\n        return *this;\r\n   \
    \ }\r\n    fp &operator/=(const fp &x) {\r\n        v = ull(v) * x.inv() % mod;\r\
    \n        return *this;\r\n    }\r\n    fp operator+(const fp &x) const {\r\n\
    \        return fp(*this) += x;\r\n    }\r\n    fp operator-(const fp &x) const\
    \ {\r\n        return fp(*this) -= x;\r\n    }\r\n    fp operator*(const fp &x)\
    \ const {\r\n        return fp(*this) *= x;\r\n    }\r\n    fp operator/(const\
    \ fp &x) const {\r\n        return fp(*this) /= x;\r\n    }\r\n    bool operator==(const\
    \ fp &x) const {\r\n        return v == x.v;\r\n    }\r\n    bool operator!=(const\
    \ fp &x) const {\r\n        return v != x.v;\r\n    }\r\n    friend istream &operator>>(istream\
    \ &is, fp &x) {\r\n        return is >> x.v;\r\n    }\r\n    friend ostream &operator<<(ostream\
    \ &os, const fp &x) {\r\n        return os << x.v;\r\n    }\r\n};\r\n\r\ntemplate\
    \ <unsigned mod> void rd(fp<mod> &x) {\r\n    fastio::rd(x.v);\r\n}\r\ntemplate\
    \ <unsigned mod> void wt(fp<mod> x) {\r\n    fastio::wt(x.v);\r\n}\r\n\r\ntemplate\
    \ <typename T> T Inv(ll n) {\r\n    static const int md = T::get_mod();\r\n  \
    \  static vector<T> buf({0, 1});\r\n    assert(n > 0);\r\n    n %= md;\r\n   \
    \ while (SZ(buf) <= n) {\r\n        int k = SZ(buf), q = (md + k - 1) / k;\r\n\
    \        buf.push_back(buf[k * q - md] * q);\r\n    }\r\n    return buf[n];\r\n\
    }\r\n\r\ntemplate <typename T> T Fact(ll n, bool inv = 0) {\r\n    static const\
    \ int md = T::get_mod();\r\n    static vector<T> buf({1, 1}), ibuf({1, 1});\r\n\
    \    assert(n >= 0 and n < md);\r\n    while (SZ(buf) <= n) {\r\n        buf.push_back(buf.back()\
    \ * SZ(buf));\r\n        ibuf.push_back(ibuf.back() * Inv<T>(SZ(ibuf)));\r\n \
    \   }\r\n    return inv ? ibuf[n] : buf[n];\r\n}\r\n\r\ntemplate <typename T>\
    \ T nPr(int n, int r, bool inv = 0) {\r\n    if (n < 0 || n < r || r < 0)\r\n\
    \        return 0;\r\n    return Fact<T>(n, inv) * Fact<T>(n - r, inv ^ 1);\r\n\
    }\r\ntemplate <typename T> T nCr(int n, int r, bool inv = 0) {\r\n    if (n <\
    \ 0 || n < r || r < 0)\r\n        return 0;\r\n    return Fact<T>(n, inv) * Fact<T>(r,\
    \ inv ^ 1) * Fact<T>(n - r, inv ^ 1);\r\n}\r\ntemplate <typename T> T nHr(int\
    \ n, int r, bool inv = 0) {\r\n    return nCr<T>(n + r - 1, r, inv);\r\n}\r\n\r\
    \n/**\r\n * @brief Modint\r\n */\n"
  code: "#pragma once\r\n\r\ntemplate <unsigned mod = 1000000007> struct fp {\r\n\
    \    unsigned v;\r\n    static constexpr int get_mod() {\r\n        return mod;\r\
    \n    }\r\n    constexpr unsigned inv() const {\r\n        assert(v != 0);\r\n\
    \        int x = v, y = mod, p = 1, q = 0, t = 0, tmp = 0;\r\n        while (y\
    \ > 0) {\r\n            t = x / y;\r\n            x -= t * y, p -= t * q;\r\n\
    \            tmp = x, x = y, y = tmp;\r\n            tmp = p, p = q, q = tmp;\r\
    \n        }\r\n        if (p < 0)\r\n            p += mod;\r\n        return p;\r\
    \n    }\r\n    constexpr fp(ll x = 0) : v(x >= 0 ? x % mod : (mod - (-x) % mod)\
    \ % mod) {}\r\n    fp operator-() const {\r\n        return fp() - *this;\r\n\
    \    }\r\n    fp pow(ull t) {\r\n        fp res = 1, b = *this;\r\n        while\
    \ (t) {\r\n            if (t & 1)\r\n                res *= b;\r\n           \
    \ b *= b;\r\n            t >>= 1;\r\n        }\r\n        return res;\r\n    }\r\
    \n    fp &operator+=(const fp &x) {\r\n        if ((v += x.v) >= mod)\r\n    \
    \        v -= mod;\r\n        return *this;\r\n    }\r\n    fp &operator-=(const\
    \ fp &x) {\r\n        if ((v += mod - x.v) >= mod)\r\n            v -= mod;\r\n\
    \        return *this;\r\n    }\r\n    fp &operator*=(const fp &x) {\r\n     \
    \   v = ull(v) * x.v % mod;\r\n        return *this;\r\n    }\r\n    fp &operator/=(const\
    \ fp &x) {\r\n        v = ull(v) * x.inv() % mod;\r\n        return *this;\r\n\
    \    }\r\n    fp operator+(const fp &x) const {\r\n        return fp(*this) +=\
    \ x;\r\n    }\r\n    fp operator-(const fp &x) const {\r\n        return fp(*this)\
    \ -= x;\r\n    }\r\n    fp operator*(const fp &x) const {\r\n        return fp(*this)\
    \ *= x;\r\n    }\r\n    fp operator/(const fp &x) const {\r\n        return fp(*this)\
    \ /= x;\r\n    }\r\n    bool operator==(const fp &x) const {\r\n        return\
    \ v == x.v;\r\n    }\r\n    bool operator!=(const fp &x) const {\r\n        return\
    \ v != x.v;\r\n    }\r\n    friend istream &operator>>(istream &is, fp &x) {\r\
    \n        return is >> x.v;\r\n    }\r\n    friend ostream &operator<<(ostream\
    \ &os, const fp &x) {\r\n        return os << x.v;\r\n    }\r\n};\r\n\r\ntemplate\
    \ <unsigned mod> void rd(fp<mod> &x) {\r\n    fastio::rd(x.v);\r\n}\r\ntemplate\
    \ <unsigned mod> void wt(fp<mod> x) {\r\n    fastio::wt(x.v);\r\n}\r\n\r\ntemplate\
    \ <typename T> T Inv(ll n) {\r\n    static const int md = T::get_mod();\r\n  \
    \  static vector<T> buf({0, 1});\r\n    assert(n > 0);\r\n    n %= md;\r\n   \
    \ while (SZ(buf) <= n) {\r\n        int k = SZ(buf), q = (md + k - 1) / k;\r\n\
    \        buf.push_back(buf[k * q - md] * q);\r\n    }\r\n    return buf[n];\r\n\
    }\r\n\r\ntemplate <typename T> T Fact(ll n, bool inv = 0) {\r\n    static const\
    \ int md = T::get_mod();\r\n    static vector<T> buf({1, 1}), ibuf({1, 1});\r\n\
    \    assert(n >= 0 and n < md);\r\n    while (SZ(buf) <= n) {\r\n        buf.push_back(buf.back()\
    \ * SZ(buf));\r\n        ibuf.push_back(ibuf.back() * Inv<T>(SZ(ibuf)));\r\n \
    \   }\r\n    return inv ? ibuf[n] : buf[n];\r\n}\r\n\r\ntemplate <typename T>\
    \ T nPr(int n, int r, bool inv = 0) {\r\n    if (n < 0 || n < r || r < 0)\r\n\
    \        return 0;\r\n    return Fact<T>(n, inv) * Fact<T>(n - r, inv ^ 1);\r\n\
    }\r\ntemplate <typename T> T nCr(int n, int r, bool inv = 0) {\r\n    if (n <\
    \ 0 || n < r || r < 0)\r\n        return 0;\r\n    return Fact<T>(n, inv) * Fact<T>(r,\
    \ inv ^ 1) * Fact<T>(n - r, inv ^ 1);\r\n}\r\ntemplate <typename T> T nHr(int\
    \ n, int r, bool inv = 0) {\r\n    return nCr<T>(n + r - 1, r, inv);\r\n}\r\n\r\
    \n/**\r\n * @brief Modint\r\n */"
  dependsOn: []
  isVerificationFile: false
  path: Math/modint.hpp
  requiredBy:
  - Math/bigint.hpp
  - Convolution/arbitrary.hpp
  timestamp: '2024-04-26 03:18:17+09:00'
  verificationStatus: LIBRARY_ALL_WA
  verifiedWith:
  - Verify/LC_sum_of_totient_function.test.cpp
  - Verify/LC_convolution_mod_1000000007.test.cpp
  - Verify/LC_stirling_number_of_the_first_kind.test.cpp
  - Verify/LC_inv_of_formal_power_series.test.cpp
  - Verify/LC_point_set_range_sort_range_composite.test.cpp
  - Verify/LC_many_factorials.test.cpp
  - Verify/LC_kth_term_of_linearly_recurrent_sequence.test.cpp
  - Verify/LC_multivariate_convolution_cyclic.test.cpp
  - Verify/LC_multipoint_evaluation.test.cpp
  - Verify/LC_product_of_polynomial_sequence.test.cpp
  - Verify/LC_bernoulli_number.test.cpp
  - Verify/LC_matrix_det.test.cpp
  - Verify/LC_hafnian_of_matrix.test.cpp
  - Verify/LC_sum_of_exponential_times_polynomial_limit.test.cpp
  - Verify/LC_find_linear_recurrence.test.cpp
  - Verify/YUKI_1080.test.cpp
  - Verify/LC_bitwise_xor_convolution.test.cpp
  - Verify/LC_convolution_mod.test.cpp
  - Verify/LC_sum_of_exponential_times_polynomial.test.cpp
  - Verify/LC_convolution_mod_2.test.cpp
  - Verify/LC_log_of_formal_power_series.test.cpp
  - Verify/LC_system_of_linear_equations.test.cpp
  - Verify/LC_sparse_matrix_det.test.cpp
  - Verify/LC_partition_function.test.cpp
  - Verify/LC_queue_operate_all_composite.test.cpp
  - Verify/LC_dynamic_tree_vertex_set_path_composite.test.cpp
  - Verify/LC_point_set_range_composite.test.cpp
  - Verify/LC_matrix_product.test.cpp
  - Verify/LC_exp_of_formal_power_series.test.cpp
  - Verify/LC_enumerate_cliques.test.cpp
  - Verify/LC_static_rectangle_add_rectangle_sum.test.cpp
  - Verify/YUKI_1781.test.cpp
  - Verify/LC_vertex_set_path_composite.test.cpp
  - Verify/LC_stirling_number_of_the_second_kind.test.cpp
  - Verify/YUKI_310.test.cpp
  - Verify/LC_shift_of_sampling_points_of_polynomial.test.cpp
  - Verify/YUKI_1112.test.cpp
  - Verify/LC_bitwise_and_convolution.test.cpp
  - Verify/LC_pow_of_formal_power_series.test.cpp
  - Verify/YUKI_2097.test.cpp
  - Verify/LC_deque_operate_all_composite.test.cpp
  - Verify/LC_range_affine_range_sum.test.cpp
  - Verify/LC_subset_convolution.test.cpp
  - Verify/LC_polynomial_interpolation.test.cpp
  - Verify/LC_multivariate_convolution.test.cpp
  - Verify/LC_gcd_convolution.test.cpp
  - Verify/LC_lcm_convolution.test.cpp
  - Verify/LC_polynomial_taylor_shift.test.cpp
documentation_of: Math/modint.hpp
layout: document
redirect_from:
- /library/Math/modint.hpp
- /library/Math/modint.hpp.html
title: Modint
---
